struct dlfcn_hook *_dlfcn_hook __attribute__((nocommon));
---------------------------------------------------------
```
定义DLDCN.h
-----------
struct dlfcn_hook
{
  void *(*dlopen) (const char *file, int mode, void *dl_caller);
  int (*dlclose) (void *handle);
  void *(*dlsym) (void *handle, const char *name, void *dl_caller);
  void *(*dlvsym) (void *handle, const char *name, const char *version,
		   void *dl_caller);
  char *(*dlerror) (void);
  int (*dladdr) (const void *address, Dl_info *info);
  int (*dladdr1) (const void *address, Dl_info *info,
		  void **extra_info, int flags);
  int (*dlinfo) (void *handle, int request, void *arg, void *dl_caller);
  void *(*dlmopen) (Lmid_t nsid, const char *file, int mode, void *dl_caller);
  void *pad[4];
};
初始化
-----
# ifdef SHARED

struct dlfcn_hook *_dlfcn_hook __attribute__((nocommon));
libdl_hidden_data_def (_dlfcn_hook)

# else

static struct dlfcn_hook _dlfcn_hooks =
  {
    .dlopen = __dlopen,
    .dlclose = __dlclose,
    .dlsym = __dlsym,
    .dlvsym = __dlvsym,
    .dlerror = __dlerror,
    .dladdr = __dladdr,
    .dladdr1 = __dladdr1,
    .dlinfo = __dlinfo,
    .dlmopen = __dlmopen
  };
  ```
 ```
结合本次实验中
 if (__builtin_expect (_dlfcn_hook != NULL, 0))#现在——dlfcn_hook是一个地址，初始化的时候初始化为8字节的0x0，
 (gdb) p _dlfcn_hook 
$5 = (struct dlfcn_hook *) 0x0#意思是0x0这个地址下的类型为struct dlfcn_hook
```
```
再次解释struct dlfcn_hook *_dlfcn_hook __attribute__((nocommon));
https://www.ibm.com/support/knowledgecenter/en/SSXVZZ_13.1.6/com.ibm.xlcpp1316.lelinux.doc/language_ref/var_attrib_nocommon.html
The variable attribute common allows you to specify that an uninitialized global variable or a global variable explicitly initialized to 0 should be allocated in the common section of the object file. The variable attribute nocommon specifies that an uninitialized global variable should be allocated in the data section of the object file. The variable is automatically initialized to zero.

Read syntax diagramSkip visual syntax diagram
nocommon and common variable attribute syntax

>>-__attribute__--((--+--------------+--))---------------------><
                      +-nocommon-----+       
                      +-__nocommon__-+       
                      +-common-------+       
                      '-__common__---'       

For example:
int i __attribute__((nocommon));      /* allocate i at .data  */
int k __attribute__((common));        /* allocate k at .comm  */copy to clipboard
You can only apply the variable attributes to global scalar or aggregate variables. If you try to assign either attribute to a static or automatic variable or structure or union member, the attribute is ignored and a warning is issued.
```
```
C语言中的条件运算符（?:）用法
---------------------------
 使用条件运算符（?:）可以实现 If Else 的功能，其一般形式为：

        Exp1 ? Exp2 : Exp3

显而易见，条件运算符（Conditional Operator）有三个操作数，故我们将其称为三目运算符（Ternary Operator）。条件运算符是 C 语言中唯一一个三目运算符。我们把上面这个表达式称为条件表达式。这个条件表达式的意思是，如果 Exp1 为真，则运算 Exp2，整个条件表达式的值为 Exp2 的值；反之，则运算 Exp3，整个条件表达式的值为 Exp3 的值。例如：
```
DL_DST_COUNT用于统计路径s中特殊符号的个数，这些特殊符号包括“ORIGIN”，“PLATFORM”，“LIB”等，具体这些符号的作用可以上网上查，例如ORIGIN就代表可执行文件所在目录。 
接下来如果路径中没有这些特殊符号，则通过local_strdup函数拷贝路径s并返回。 
如果包含了这些特殊符号，首先通过DL_DST_REQUIRED宏计算将特殊符号替换成实际值后的路径长度total，并根据该长度分配内存空间result，最后通过_dl_dst_substitute函数替换特殊字符串并返回替换后的字符串。
```
```
在GLIBC里查找系统调用
--------------------
有些系统调用在GLIBC里是找不到相应的函数的. 这一类函数会按照 sysdeps/unix/syscall-template.S 里的参数要求在 sysdeps/unix/syscall.S里定义每一个系统调用. 编译的时候,sysdev/unix/make-syscalls.sh 会根据上面的文件生成每个函数的汇编代码到 glibc库里面.
比如, 如果查看 mmap 的反汇编)(MIPS),你会看到:
(gdb) disass mmap  
Dump of assembler code for function mmap:  
   0x77f3107c <+0>:   lui gp,0xa  
   0x77f31080 <+4>:   addiu   gp,gp,-29292  
   0x77f31084 <+8>:   addu    gp,gp,t9  
   0x77f31088 <+12>:  li  v0,4090  
   0x77f3108c <+16>:  syscall  
   0x77f31090 <+20>:  bnez    a3,0x77f31070  
   0x77f31094 <+24>:  nop  
   0x77f31098 <+28>:  jr  ra  
   0x77f3109c <+32>:  nop  
   0x77f310a0 <+36>:  nop  
 查看  mmap的源码:

(gdb) list mmap  
76  #else  
77    
78  /* This is a "normal" system call stub: if there is an error,  
79     it returns -1 and sets errno.  */  
80    
81  T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)  
82      ret  
83  T_PSEUDO_END (SYSCALL_SYMBOL)  
84    
85  #endif  

../sysdeps/unix/syscall-template.S:82  

其中, T_PSEUDO定义为:
# define PSEUDO(name, syscall_name, args)                     \  
  .align 2;                                   \  
  99: la t9,__syscall_error;                              \  
  jr t9;                                      \  
  ENTRY (name)                                    \  
    .set noreorder;                               \  
    .cpload t9;                                   \  
    .set reorder;                                 \  
    SINGLE_THREAD_P(t0);                              \  
    bne zero, t0, L(pseudo_cancel);                       \  
    .set noreorder;                               \  
    li v0, SYS_ify(syscall_name);                         \  
    syscall;                                      \  
    .set reorder;                                 \  
    bne a3, zero, SYSCALL_ERROR_LABEL;                            \  
    ret;    
    基本上和前面的反汇编代码是一致的.
```

    
